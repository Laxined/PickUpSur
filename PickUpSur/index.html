<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PickUpSur</title>
</head>
<style>
    body {
        font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    }

     #myCanvas {
        display: block;
        margin: 19px auto 0px auto;
    }

    canvas {
     background-color: grey;
    }

    h1 {
     text-align: center;
      font-size: 350%;
    }

    h2 {
        text-align: center;
        font-size: 200%;
    }
</style>
<body onload="alert('To see Controls hold Q.')">
    <h2>Inventory Status: <span id="Inventory"></span></h2>
    <div class="mid">
    <canvas id="myCanvas" width="1500" height="900" style="border:5px solid black">
        Your browser does not support the canvas element.
    </canvas>
    </div>
</body>
<script>
      var canvas = document.getElementById("myCanvas");
      var ctx = canvas.getContext("2d");
      

      window.addEventListener('keydown', this.onKey, false);
      window.addEventListener('keyup', this.onKeyUp, false);

      let inventoryElement = document.getElementById("Inventory");

      let positionX = 400;
      let positionY = 400;
      let plSzX = 50;
      let plSzY = 50;
      let speedX = 0;
      let speedY = 0;

      let E = false;
      let EPush = false;

      let MaterialInInventory = false;
      let npcStatus = 0;
      let talk = 0;

      let Q = false;
      let QPush = false;
      let levl = 1;

      let level = {
        tutorial: {
            background: "to do",

        npc: [
                {x:600, y:75, sx:75, sy:75, skin:"red", name:"Lucio", talk1: [
                            { a: ""},
                            { b: "-- Hi, My name is Lucio, but you know that already."},
                            { c: "-- Our car has unfortunatly crashed here."},
                            { d: "-- So now, we need to get some wood for repair."},
                            { e: "-- You go get it and I'll be here and watch the car."},
                            { f: "-- When you'll find it, bring it here to me, Good Luck."},
                          ], 
                    talk2: [
                            {a: ""},
                            {b: "-- Oh, you really did it! Whisper:'I didn't really expect that.'"},
                            {c: "-- Now we can go! When you're ready, come here and press'E'."},
                    ]
                }],
        enemies: [
                {enemyList: [
                    newEnemy(400, 600, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
                    newEnemy(400, 600, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
                    newEnemy(400, 750, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
                    newEnemy(400, 750, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
                    ],
                stillEnemyList: [
                    newStillEnemy(0, 550, 83, 50, 2, "black"),
                    newStillEnemy(500, 550, 83, 50, 2, "black"),
                    ]}
                ],
        items: [
         newMaterial (600, 750, 50, 50, "brown", "wood"),
        ]

        }
      }

      let active = level.tutorial;

      let sentenc = "";

      let controls = [
        {x:20, y:25, al:"40px Lucida sans", tl:"Controls:"},
        {x:20, y:50, al:"25px Lucida sans", tl:"Movement - WASD"},
        {x:20, y:78, al:"25px Lucida sans", tl:"To Interaction press 'E'"},
        {x:20, y:106, al:"25px Lucida sans", tl:"To pick up something press 'E'"},
        {x:20, y:132, al:"25px Lucida sans", tl:"You can have only 1 thing in Inventory."},
      ]

        function newEnemy(x, y, sx, sy, fr, ang, sk, sp) {
            return {x:x, y:y, sx:sx, sy:sy, fr:fr, ang:ang, sk:sk, sp:sp}
        }

        function newStillEnemy(x, y, sx, sy, sp, sk) {
            return {x:x, y:y, sx:sx, sy:sy, sp:sp, sk:sk}
        }

        function newMaterial(x, y, sx, sy, sk, name) {
            return {x:x, y:y, sx:sx, sy:sy, sk:sk, name:name}
        }

      function onKey(event) {
            if (event.keyCode == 65 || event.keyCode == 37) {
                speedX = -8;
            }
            if (event.keyCode == 68 || event.keyCode == 39) {
                speedX = 8;
            }
			if (event.keyCode == 87 || event.keyCode == 38) {
               speedY = -8;
			}
			if (event.keyCode == 83 || event.keyCode == 40) {
              speedY = 8;
			}

            if (event.code == "KeyE") {
                E = true;
            }

            if (event.code == "KeyQ") {
                Q = true;
            }

        }

        function onKeyUp() {
                if (event.code == "KeyW" || event.code == "KeyS" || event.code == "ArrowUp" || event.code == "ArrowDown" ) {
                    speedY = 0;
                }
                if ( event.code == "KeyA" || event.code == "KeyD"||  event.code == "ArrowLeft" || event.code == "ArrowRight") {
                    speedX = 0;
                }

                if (event.code == "KeyE") {
                    E = false;
                    EPush = false;
                }

                if (event.code == "KeyQ") {
                    Q = false;
                    QPush = false;
                }
            }

    function draw() {
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

        enemyMovement();  //hybani random enemy
        stillEnemyMovement(); //hybani stillEnemy
        CooperatingWithNPC(); //npc veci
        InventoryControl();  // inv veci
        Controls();  //controls
        collisionWithEnemy();  //kolize

        positionX += speedX;
        positionY += speedY;

        ctx.fillStyle = "blue";
        ctx.fillRect(positionX, positionY, plSzX, plSzY);

        ctx.fillStyle = npc.sk;
        ctx.fillRect(npc.x, npc.y, npc.sx, npc.sy);

        if (positionY <= 0){
			    positionY += 8;
			}
			if (positionY + plSzY >= canvas.height) {
			    positionY -= 8;
			}
			if (positionX <= 0) {
			    positionX += 8;
			}
			if (positionX + plSzX >= canvas.width) {
			    positionX -= 8;
			}

        for (stillEnemy of active.enemies.stillEnemyList) {
            ctx.fillStyle = stillEnemy.sk;
            ctx.fillRect(stillEnemy.x, stillEnemy.y, stillEnemy.sx, stillEnemy.sy);
        }
        for (enemy of active.enemies.enemyList) {
            ctx.fillStyle = enemy.sk;
            ctx.fillRect(enemy.x, enemy.y, enemy.sx, enemy.sy);
        }
        for (npc of active.npc) {
            ctx.fillStyle = npc.sk;
            ctx.fillRect(npc.x, npc.y, npc.sx, npc.sy);
        }
        for (material of active.items) {
            ctx.fillStyle = material.sk;
            ctx.fillRect(material.x, material.y, material.sx, material.sy);
        }
    }

    function CooperatingWithNPC() {
        if (npcStatus == 0) {
            if (talk == 1) { sentenc = speech1.b  }
            if (talk == 2) { sentenc = speech1.c }
            if (talk == 3) { sentenc = speech1.d }
            if (talk == 4) { sentenc = speech1.e }
            if (talk == 5) { sentenc = speech1.f }
            if (talk == 6) { sentenc = speech1.a; npcStatus = 1} 
        }

        text("28px Lucida sans", "Black", "center", npc.x, npc.y - 25, sentenc)

        if (npcStatus == 2) {
              if (talk == 1) { sentenc = speech2.b }
              if (talk == 2) { sentenc = speech2.c }
              if (talk == 3) { sentenc = speech2.a ; npcStatus = 3}
         }

         if (npcStatus == 3 && E == true) {
            if (collision(positionX, npc.x, plSizeX, npc.sx, 0) && collision(positionY, npc.y, plSizeY, npc.sy, 0)) {
                level = 2;
            }
         }

        if (talk <= 5 && E == true && EPush == false && collision(positionX, npc.x, plSizeX, npc.sx, 0) && collision(positionY, npc.y, plSizeY, npc.sy, 0)) {
            talk++ ;
            EPush = true;
        }

        if (E == true && npcStatus == 1 && MaterialInInventory == true) {
            if (collision(positionX, npc.x, plSizeX, npc.sx, 0) && collision(positionY, npc.y, plSizeY, npc.sy, 0)) {
                MaterialInInventory = false;
                npcStatus = 2;
                talk = 0;
            }
        }
    }

    function InventoryControl() {
        if (MaterialInInventory == true) {
            inventoryElement.innerHTML = "Wood";
        }

        if (MaterialInInventory == false) {
            inventoryElement.innerHTML = "  You have empty bag."
        }

        if (E == true && talk == 6) {
                for (material of materialQuest) {
                   if (collision(positionX, material.x, plSizeX, material.sx, 0) && collision(positionY, material.y, plSizeY, material.sy, 0)) {
                        materialQuest.shift();
                        MaterialInInventory = true;
                 }
             }
        }
    }

    function Controls() {
        if (Q == true) {
            for (control of controls) {
                text(control.al, "black", "left", control.x, control.y, control.tl);
         }
        }
    }

    function text(font, cl, align, x, y, text) {
        ctx.font = font;
        ctx.fillStyle = cl;
        ctx.textAlign = align;
        ctx.fillText(text, x, y);
    }

    function collisionWithEnemy() {
        for (enemy of active.enemies.enemyList) {
            if (collision(positionX, enemy.x, plSzX, enemy.sx, 0) && collision(positionY, enemy.y, plSzY, enemy.sy, 0)) {
                alert("test");
            }
        }

       for (stillEnemy of active.enemies.stillEnemyList) {
            if (collision(positionX, stillEnemy.x, plSzX, stillEnemy.sx, 0) && collision(positionY, stillEnemy.y, plSzY, stillEnemy.sy, 0)) {
                alert("test");
            }
        }
    }

    function collision(obj1, obj2, sz1, sz2, dis) {
            let midd1 = obj1 + sz1 / 2;
			let midd2 = obj2 + sz2 / 2;
			let min = (sz1 + sz2 + dis) / 2;
			let diff = Math.abs (midd1 - midd2);
			return diff < min;
    }

    function enemyMovement() {
        for (enemy of active.enemies.enemyList) {
            if (!enemy.fr) {
            enemy.x += Math.cos(enemy.ang) * enemy.sp;
            enemy.y += Math.sin(enemy.ang) * enemy.sp;

            if (Math.random() < 0.05) enemy.ang = Math.random() * Math.PI * 2;

            if (enemy.x <= 0) enemy.ang = Math.PI - enemy.ang;
            if (enemy.x + enemy.sx >= canvas.width) enemy.ang = Math.PI - enemy.ang;

            if (enemy.y <= 350) enemy.ang = -enemy.ang;
            if (enemy.y + enemy.sy >= canvas.height) enemy.ang = -enemy.ang;

         }
      }
    }

    function stillEnemyMovement() {
        for (stillEnemy of active.enemies.stillEnemyList) {
            stillEnemy.x += stillEnemy.sp;
            if (stillEnemy.x >= canvas.width) stillEnemy.x = 0;
        }
    }
    setInterval(draw, 15);
</script>
</html>
