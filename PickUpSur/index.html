<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PickUpSur</title>
</head>
<style>
    body {
        font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    }

     .mid {
        display: block;
        margin: 28%;
        margin-top: 0%;
        margin-bottom: 0%;
    }

    canvas {
     background-color: grey;;
    }

    h1 {
     text-align: center;
      font-size: 350%;
    }
</style>
<body>

    <h1>To do</h1>
    <div class="mid">
    <canvas id="myCanvas" width="800" height="1000" style="border:5px solid black">
        Your browser does not support the canvas element.
    </canvas>
    </div>
</body>
<script>
      var canvas = document.getElementById("myCanvas");
      var ctx = canvas.getContext("2d");
      

      window.addEventListener('keydown', this.onKey, false);
      window.addEventListener('keyup', this.onKeyUp, false);
    

      let posX = 400;
      let posY = 400;
      let plSizeX = 60;
      let plSizeY = 30;
      let speedX = 0;
      let speedY = 0;

      let E = false;
      let MaterialInInventory = false;

        let npc = {x: 600, y: 75, sx: 75, sy: 75, sk: "red"};


        let enemyList = [
            newEnemy(400, 600, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
            newEnemy(400, 600, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
            newEnemy(400, 750, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
            newEnemy(400, 750, 83, 50, false, Math.PI * 2 * Math.random(), "black", 5),
        ]

        function newEnemy(x, y, szX, szY, fr, ang, sk, sp) {
            return {x: x, y: y, szX: szX, szY: szY, fr: fr, ang: ang, sk: sk, sp:sp}
        }

        let stillEnemyList = [
            newStillEnemy(0, 550, 83, 50, 2, "black"),
            newStillEnemy(500, 550, 83, 50, 2, "black"),
        ]

        function newStillEnemy(x, y, sx, sy, sp, sk) {
            return {x:x, y:y, sx:sx, sy:sy, sp:sp, sk:sk}
        }

        let materialQuest = [
            newMaterial (600, 750, 50, 50, "brown", "wood"),
        ]

        function newMaterial(x, y, sx, sy, sk, name) {
            return {x:x, y:y, sx:sx, sy:sy, sk:sk, name:name}
        }

      function onKey(event) {
            if (event.keyCode == 65 || event.keyCode == 37) {
                speedX = -8;
            }
            if (event.keyCode == 68 || event.keyCode == 39) {
                speedX = 8;
            }
			if (event.keyCode == 87 || event.keyCode == 38) {
               speedY = -8;
			}
			if (event.keyCode == 83 || event.keyCode == 40) {
              speedY = 8;
			}

            if (event.code == "KeyE") {
                E = true;
            }

        }

        function onKeyUp() {
                if (event.code == "KeyW" || event.code == "KeyS" || event.code == "ArrowUp" || event.code == "ArrowDown" ) {
                    speedY = 0;
                }
                if ( event.code == "KeyA" || event.code == "KeyD"||  event.code == "ArrowLeft" || event.code == "ArrowRight") {
                    speedX = 0;
                }

                if (event.code == "KeyE") {
                    E = false;
                }
            }

    function draw() {
        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

        enemyMovement();
        stillEnemyMovement();
        posX += speedX;
        posY += speedY;

        ctx.fillStyle = "red";
        ctx.fillRect(posX, posY, plSizeX, plSizeY);

        ctx.fillStyle = npc.sk;
        ctx.fillRect(npc.x, npc.y, npc.sx, npc.sy);

        if (posY <= 0){
			    posY += 8;
			}
			if (posY + plSizeY >= canvas.height) {
			    posY -= 8;
			}
			if (posX <= 0) {
			    posX += 8;
			}
			if (posX + plSizeX >= canvas.width) {
			    posX -= 8;
			}

        for (stillEnemy of stillEnemyList) {
            ctx.fillStyle = stillEnemy.sk;
            ctx.fillRect(stillEnemy.x, stillEnemy.y, stillEnemy.sx, stillEnemy.sy);
        }
        for (enemy of enemyList) {
            ctx.fillStyle = enemy.sk;
            ctx.fillRect(enemy.x, enemy.y, enemy.szX, enemy.szY);
        }

        for (material of materialQuest) {
            ctx.fillStyle = material.sk;
            ctx.fillRect(material.x, material.y, material.sx, material.sy);
        }

        text("30px Lucida sans", "Black", "center", 650, 50, "Hi, I need some wood.")

        if (E == true) {
                for (material of materialQuest) {
                   if (collision(posX, material.x, plSizeX, material.sx, 0) && collision(posY, material.y, plSizeY, material.sy, 0)) {
                        materialQuest.shift();
                        MaterialInInventory = true;
                 }
             }
        }

        if (E == true) {
            //odevzdani materialu npc
        }
    }

    function text(font, cl, align, x, y, text) {
        ctx.font = font;
        ctx.fillStyle = cl;
        ctx.textAlign = align;
        ctx.fillText(text, x, y);
    }

    function collision(obj1, obj2, sz1, sz2, dis) {
            let midd1 = obj1 + sz1 / 2;
			let midd2 = obj2 + sz2 / 2;
			let min = (sz1 + sz2 + dis) / 2;
			let diff = Math.abs (midd1 - midd2);
			return diff < min;
    }

    function enemyMovement() {
        for (enemy of enemyList) {
            if (!enemy.fr) {
            enemy.x += Math.cos(enemy.ang) * enemy.sp;
            enemy.y += Math.sin(enemy.ang) * enemy.sp;

            if (Math.random() < 0.05) enemy.ang = Math.random() * Math.PI * 2;

            if (enemy.x <= 0) enemy.ang = Math.PI - enemy.ang;
            if (enemy.x + enemy.szX >= canvas.width) enemy.ang = Math.PI - enemy.ang;

            if (enemy.y <= 350) enemy.ang = -enemy.ang;
            if (enemy.y + enemy.szY >= canvas.height) enemy.ang = -enemy.ang;

         }
      }
    }

    function stillEnemyMovement() {
        for (stillEnemy of stillEnemyList) {
            stillEnemy.x += stillEnemy.sp;
            if (stillEnemy.x >= canvas.width) stillEnemy.x = 0;
        }
    }
    setInterval(draw, 15);
</script>
</html>
